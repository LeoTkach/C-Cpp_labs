#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <codecvt>
#include <locale>
#include <iomanip>

class UTF16FileProcessor {
private:
    std::string inputFilePath;
    std::string outputFilePath;
    std::vector<char16_t> fileBytes;
    std::vector<std::u16string> lines;
    char16_t bomMarker = 0xFEFF; // UTF-16 Little Endian BOM

    // Helper method to detect if a character is a line ending
    bool isLineEnding(char16_t ch) {
        return ch == 0x000D || ch == 0x000A;
    }

public:
    UTF16FileProcessor(const std::string& input, const std::string& output)
        : inputFilePath(input), outputFilePath(output) {}

    bool readFile() {
        std::ifstream inputFile(inputFilePath, std::ios::binary | std::ios::ate);
        if (!inputFile) {
            std::cerr << "Error: Could not open input file" << std::endl;
            return false;
        }

        // Get file size
        std::streampos fileSize = inputFile.tellg();
        inputFile.seekg(0, std::ios::beg);

        // Read entire file contents
        std::vector<char> rawBytes(fileSize);
        if (!inputFile.read(rawBytes.data(), fileSize)) {
            std::cerr << "Error: Failed to read file contents" << std::endl;
            return false;
        }

        // Convert raw bytes to UTF-16
        fileBytes.clear();
        for (size_t i = 2; i + 1 < rawBytes.size(); i += 2) {
            char16_t ch = (rawBytes[i + 1] << 8) | rawBytes[i];
            fileBytes.push_back(ch);
        }

        return true;
    }

    void splitIntoLines() {
        std::u16string currentLine;
        for (size_t i = 0; i < fileBytes.size(); ++i) {
            char16_t ch = fileBytes[i];

            currentLine += ch;

            // Check for line endings (0D 0A or 0A or 0D)
            if (ch == 0x000D || ch == 0x000A) {
                // Special handling for CRLF
                if (ch == 0x000D && i + 1 < fileBytes.size() && fileBytes[i + 1] == 0x000A) {
                    currentLine += fileBytes[++i];
                }

                lines.push_back(currentLine);
                currentLine.clear();
            }
        }

        // Add last line if not empty
        if (!currentLine.empty()) {
            lines.push_back(currentLine);
        }
    }

    void reverseLines() {
        for (auto& line : lines) {
            // Find line ending position
            size_t endingPos = line.length();
            while (endingPos > 0 && isLineEnding(line[endingPos - 1])) {
                endingPos--;
            }

            // Reverse characters before line ending
            std::reverse(line.begin(), line.begin() + endingPos);
        }
    }

    bool writeToFile() {
        std::ofstream outputFile(outputFilePath, std::ios::binary);
        if (!outputFile) {
            std::cerr << "Error: Could not open output file" << std::endl;
            return false;
        }

        // First, write the BOM marker
        outputFile.put(bomMarker & 0xFF);
        outputFile.put((bomMarker >> 8) & 0xFF);

        // Write each line
        for (const auto& line : lines) {
            // Convert each character to two bytes (little-endian)
            for (char16_t ch : line) {
                char lowByte = ch & 0xFF;
                char highByte = (ch >> 8) & 0xFF;
                outputFile.put(lowByte);
                outputFile.put(highByte);
            }
        }

        outputFile.close();
        return true;
    }

    bool processFile() {
        if (!readFile()) return false;
        splitIntoLines();
        reverseLines();
        return writeToFile();
    }
};

int main() {
    try {
        // Input and output file paths
        std::string inputPath = "C:\\Users\\user\\source\\repos\\NURE_OS_lab_1\\NURE_OS_lab_1\\inputO.txt";
        std::string outputPath = "C:\\Users\\user\\source\\repos\\NURE_OS_lab_1\\NURE_OS_lab_1\\outputO.txt";

        UTF16FileProcessor processor(inputPath, outputPath);

        if (processor.processFile()) {
            std::cout << "File processed successfully!" << std::endl;
        }
        else {
            std::cout << "File processing failed." << std::endl;
        }
    }
    catch (const std::exception& e) {
        std::cerr << "Unexpected error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}